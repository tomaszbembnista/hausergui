/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "//localhost:8100/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface DeviceDTO
 */
export interface DeviceDTO {
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    externalId?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    lastSentMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    slug?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceDTO
     */
    spaceId?: number;
}
/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        _100CONTINUE = <any> '100 CONTINUE',
        _101SWITCHINGPROTOCOLS = <any> '101 SWITCHING_PROTOCOLS',
        _102PROCESSING = <any> '102 PROCESSING',
        _103CHECKPOINT = <any> '103 CHECKPOINT',
        _200OK = <any> '200 OK',
        _201CREATED = <any> '201 CREATED',
        _202ACCEPTED = <any> '202 ACCEPTED',
        _203NONAUTHORITATIVEINFORMATION = <any> '203 NON_AUTHORITATIVE_INFORMATION',
        _204NOCONTENT = <any> '204 NO_CONTENT',
        _205RESETCONTENT = <any> '205 RESET_CONTENT',
        _206PARTIALCONTENT = <any> '206 PARTIAL_CONTENT',
        _207MULTISTATUS = <any> '207 MULTI_STATUS',
        _208ALREADYREPORTED = <any> '208 ALREADY_REPORTED',
        _226IMUSED = <any> '226 IM_USED',
        _300MULTIPLECHOICES = <any> '300 MULTIPLE_CHOICES',
        _301MOVEDPERMANENTLY = <any> '301 MOVED_PERMANENTLY',
        _302FOUND = <any> '302 FOUND',
        _302MOVEDTEMPORARILY = <any> '302 MOVED_TEMPORARILY',
        _303SEEOTHER = <any> '303 SEE_OTHER',
        _304NOTMODIFIED = <any> '304 NOT_MODIFIED',
        _305USEPROXY = <any> '305 USE_PROXY',
        _307TEMPORARYREDIRECT = <any> '307 TEMPORARY_REDIRECT',
        _308PERMANENTREDIRECT = <any> '308 PERMANENT_REDIRECT',
        _400BADREQUEST = <any> '400 BAD_REQUEST',
        _401UNAUTHORIZED = <any> '401 UNAUTHORIZED',
        _402PAYMENTREQUIRED = <any> '402 PAYMENT_REQUIRED',
        _403FORBIDDEN = <any> '403 FORBIDDEN',
        _404NOTFOUND = <any> '404 NOT_FOUND',
        _405METHODNOTALLOWED = <any> '405 METHOD_NOT_ALLOWED',
        _406NOTACCEPTABLE = <any> '406 NOT_ACCEPTABLE',
        _407PROXYAUTHENTICATIONREQUIRED = <any> '407 PROXY_AUTHENTICATION_REQUIRED',
        _408REQUESTTIMEOUT = <any> '408 REQUEST_TIMEOUT',
        _409CONFLICT = <any> '409 CONFLICT',
        _410GONE = <any> '410 GONE',
        _411LENGTHREQUIRED = <any> '411 LENGTH_REQUIRED',
        _412PRECONDITIONFAILED = <any> '412 PRECONDITION_FAILED',
        _413PAYLOADTOOLARGE = <any> '413 PAYLOAD_TOO_LARGE',
        _413REQUESTENTITYTOOLARGE = <any> '413 REQUEST_ENTITY_TOO_LARGE',
        _414URITOOLONG = <any> '414 URI_TOO_LONG',
        _414REQUESTURITOOLONG = <any> '414 REQUEST_URI_TOO_LONG',
        _415UNSUPPORTEDMEDIATYPE = <any> '415 UNSUPPORTED_MEDIA_TYPE',
        _416REQUESTEDRANGENOTSATISFIABLE = <any> '416 REQUESTED_RANGE_NOT_SATISFIABLE',
        _417EXPECTATIONFAILED = <any> '417 EXPECTATION_FAILED',
        _418IAMATEAPOT = <any> '418 I_AM_A_TEAPOT',
        _419INSUFFICIENTSPACEONRESOURCE = <any> '419 INSUFFICIENT_SPACE_ON_RESOURCE',
        _420METHODFAILURE = <any> '420 METHOD_FAILURE',
        _421DESTINATIONLOCKED = <any> '421 DESTINATION_LOCKED',
        _422UNPROCESSABLEENTITY = <any> '422 UNPROCESSABLE_ENTITY',
        _423LOCKED = <any> '423 LOCKED',
        _424FAILEDDEPENDENCY = <any> '424 FAILED_DEPENDENCY',
        _425TOOEARLY = <any> '425 TOO_EARLY',
        _426UPGRADEREQUIRED = <any> '426 UPGRADE_REQUIRED',
        _428PRECONDITIONREQUIRED = <any> '428 PRECONDITION_REQUIRED',
        _429TOOMANYREQUESTS = <any> '429 TOO_MANY_REQUESTS',
        _431REQUESTHEADERFIELDSTOOLARGE = <any> '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
        _451UNAVAILABLEFORLEGALREASONS = <any> '451 UNAVAILABLE_FOR_LEGAL_REASONS',
        _500INTERNALSERVERERROR = <any> '500 INTERNAL_SERVER_ERROR',
        _501NOTIMPLEMENTED = <any> '501 NOT_IMPLEMENTED',
        _502BADGATEWAY = <any> '502 BAD_GATEWAY',
        _503SERVICEUNAVAILABLE = <any> '503 SERVICE_UNAVAILABLE',
        _504GATEWAYTIMEOUT = <any> '504 GATEWAY_TIMEOUT',
        _505HTTPVERSIONNOTSUPPORTED = <any> '505 HTTP_VERSION_NOT_SUPPORTED',
        _506VARIANTALSONEGOTIATES = <any> '506 VARIANT_ALSO_NEGOTIATES',
        _507INSUFFICIENTSTORAGE = <any> '507 INSUFFICIENT_STORAGE',
        _508LOOPDETECTED = <any> '508 LOOP_DETECTED',
        _509BANDWIDTHLIMITEXCEEDED = <any> '509 BANDWIDTH_LIMIT_EXCEEDED',
        _510NOTEXTENDED = <any> '510 NOT_EXTENDED',
        _511NETWORKAUTHENTICATIONREQUIRED = <any> '511 NETWORK_AUTHENTICATION_REQUIRED'
    }
}
/**
 * 
 * @export
 * @interface PluginDTO
 */
export interface PluginDTO {
    /**
     * 
     * @type {string}
     * @memberof PluginDTO
     */
    className?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginDTO
     */
    displayName?: string;
}
/**
 * 
 * @export
 * @interface ProcessingChainDTO
 */
export interface ProcessingChainDTO {
    /**
     * 
     * @type {number}
     * @memberof ProcessingChainDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessingChainDTO
     */
    inputDeviceId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessingChainDTO
     */
    nextId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessingChainDTO
     */
    outputDeviceId?: number;
    /**
     * 
     * @type {number}
     * @memberof ProcessingChainDTO
     */
    signalProcessorId?: number;
}
/**
 * 
 * @export
 * @interface ProcessorOperationArgument
 */
export interface ProcessorOperationArgument {
    /**
     * 
     * @type {string}
     * @memberof ProcessorOperationArgument
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorOperationArgument
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ProcessorOperationArgumentDesc
 */
export interface ProcessorOperationArgumentDesc {
    /**
     * 
     * @type {string}
     * @memberof ProcessorOperationArgumentDesc
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProcessorOperationArgumentDesc
     */
    optional?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProcessorOperationArgumentDesc
     */
    type?: ProcessorOperationArgumentDesc.TypeEnum;
}

/**
 * @export
 * @namespace ProcessorOperationArgumentDesc
 */
export namespace ProcessorOperationArgumentDesc {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        FLOAT = <any> 'FLOAT',
        INT = <any> 'INT',
        STRING = <any> 'STRING',
        DATE = <any> 'DATE',
        FLOATLIST = <any> 'FLOAT_LIST',
        INTLIST = <any> 'INT_LIST',
        STRINGLIST = <any> 'STRING_LIST',
        DATELIST = <any> 'DATE_LIST',
        VOID = <any> 'VOID'
    }
}
/**
 * 
 * @export
 * @interface ProcessorOperationDesc
 */
export interface ProcessorOperationDesc {
    /**
     * 
     * @type {Array<ProcessorOperationArgumentDesc>}
     * @memberof ProcessorOperationDesc
     */
    arguments?: Array<ProcessorOperationArgumentDesc>;
    /**
     * 
     * @type {string}
     * @memberof ProcessorOperationDesc
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessorOperationDesc
     */
    result?: ProcessorOperationDesc.ResultEnum;
}

/**
 * @export
 * @namespace ProcessorOperationDesc
 */
export namespace ProcessorOperationDesc {
    /**
     * @export
     * @enum {string}
     */
    export enum ResultEnum {
        FLOAT = <any> 'FLOAT',
        INT = <any> 'INT',
        STRING = <any> 'STRING',
        DATE = <any> 'DATE',
        FLOATLIST = <any> 'FLOAT_LIST',
        INTLIST = <any> 'INT_LIST',
        STRINGLIST = <any> 'STRING_LIST',
        DATELIST = <any> 'DATE_LIST',
        VOID = <any> 'VOID'
    }
}
/**
 * 
 * @export
 * @interface SignalProcessorDTO
 */
export interface SignalProcessorDTO {
    /**
     * 
     * @type {string}
     * @memberof SignalProcessorDTO
     */
    className?: string;
    /**
     * 
     * @type {string}
     * @memberof SignalProcessorDTO
     */
    configuration?: string;
    /**
     * 
     * @type {number}
     * @memberof SignalProcessorDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SignalProcessorDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SignalProcessorDTO
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof SignalProcessorDTO
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface SpaceDTO
 */
export interface SpaceDTO {
    /**
     * 
     * @type {number}
     * @memberof SpaceDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SpaceDTO
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof SpaceDTO
     */
    parentId?: number;
    /**
     * 
     * @type {string}
     * @memberof SpaceDTO
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface StringWrapper
 */
export interface StringWrapper {
    /**
     * 
     * @type {string}
     * @memberof StringWrapper
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}
/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}
/**
 * DeviceResourceApi - fetch parameter creator
 * @export
 */
export const DeviceResourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createDevice
         * @param {DeviceDTO} body device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceUsingPOST(body: DeviceDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDeviceUsingPOST.');
            }
            const localVarPath = `/api/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteDevice
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceUsingDELETE(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDeviceUsingDELETE.');
            }
            const localVarPath = `/api/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDevice
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceUsingGET.');
            }
            const localVarPath = `/api/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDevices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getOutputProcessingChains
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutputProcessingChainsUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOutputProcessingChainsUsingGET.');
            }
            const localVarPath = `/api/devices/{id}/output-processing-chains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateDevice
         * @param {DeviceDTO} body device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceUsingPUT(body: DeviceDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDeviceUsingPUT.');
            }
            const localVarPath = `/api/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceResourceApi - functional programming interface
 * @export
 */
export const DeviceResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createDevice
         * @param {DeviceDTO} body device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceUsingPOST(body: DeviceDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceDTO> {
            const localVarFetchArgs = DeviceResourceApiFetchParamCreator(configuration).createDeviceUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteDevice
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceUsingDELETE(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceResourceApiFetchParamCreator(configuration).deleteDeviceUsingDELETE(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDevice
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceDTO> {
            const localVarFetchArgs = DeviceResourceApiFetchParamCreator(configuration).getDeviceUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDevices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceDTO>> {
            const localVarFetchArgs = DeviceResourceApiFetchParamCreator(configuration).getDevicesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getOutputProcessingChains
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutputProcessingChainsUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessingChainDTO>> {
            const localVarFetchArgs = DeviceResourceApiFetchParamCreator(configuration).getOutputProcessingChainsUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateDevice
         * @param {DeviceDTO} body device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceUsingPUT(body: DeviceDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceDTO> {
            const localVarFetchArgs = DeviceResourceApiFetchParamCreator(configuration).updateDeviceUsingPUT(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceResourceApi - factory interface
 * @export
 */
export const DeviceResourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createDevice
         * @param {DeviceDTO} body device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceUsingPOST(body: DeviceDTO, options?: any) {
            return DeviceResourceApiFp(configuration).createDeviceUsingPOST(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteDevice
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceUsingDELETE(id: number, options?: any) {
            return DeviceResourceApiFp(configuration).deleteDeviceUsingDELETE(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDevice
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceUsingGET(id: number, options?: any) {
            return DeviceResourceApiFp(configuration).getDeviceUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDevices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesUsingGET(options?: any) {
            return DeviceResourceApiFp(configuration).getDevicesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getOutputProcessingChains
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutputProcessingChainsUsingGET(id: number, options?: any) {
            return DeviceResourceApiFp(configuration).getOutputProcessingChainsUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateDevice
         * @param {DeviceDTO} body device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceUsingPUT(body: DeviceDTO, options?: any) {
            return DeviceResourceApiFp(configuration).updateDeviceUsingPUT(body, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceResourceApi - object-oriented interface
 * @export
 * @class DeviceResourceApi
 * @extends {BaseAPI}
 */
export class DeviceResourceApi extends BaseAPI {
    /**
     * 
     * @summary createDevice
     * @param {DeviceDTO} body device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceResourceApi
     */
    public createDeviceUsingPOST(body: DeviceDTO, options?: any) {
        return DeviceResourceApiFp(this.configuration).createDeviceUsingPOST(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteDevice
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceResourceApi
     */
    public deleteDeviceUsingDELETE(id: number, options?: any) {
        return DeviceResourceApiFp(this.configuration).deleteDeviceUsingDELETE(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDevice
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceResourceApi
     */
    public getDeviceUsingGET(id: number, options?: any) {
        return DeviceResourceApiFp(this.configuration).getDeviceUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDevices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceResourceApi
     */
    public getDevicesUsingGET(options?: any) {
        return DeviceResourceApiFp(this.configuration).getDevicesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getOutputProcessingChains
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceResourceApi
     */
    public getOutputProcessingChainsUsingGET(id: number, options?: any) {
        return DeviceResourceApiFp(this.configuration).getOutputProcessingChainsUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateDevice
     * @param {DeviceDTO} body device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceResourceApi
     */
    public updateDeviceUsingPUT(body: DeviceDTO, options?: any) {
        return DeviceResourceApiFp(this.configuration).updateDeviceUsingPUT(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PluginResourceApi - fetch parameter creator
 * @export
 */
export const PluginResourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getPluginDocumentation
         * @param {string} className className
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginDocumentationUsingGET(className: string, options: any = {}): FetchArgs {
            // verify required parameter 'className' is not null or undefined
            if (className === null || className === undefined) {
                throw new RequiredError('className','Required parameter className was null or undefined when calling getPluginDocumentationUsingGET.');
            }
            const localVarPath = `/api/plugins/{className}/documentation`
                .replace(`{${"className"}}`, encodeURIComponent(String(className)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPlugin
         * @param {string} className className
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginUsingGET(className: string, options: any = {}): FetchArgs {
            // verify required parameter 'className' is not null or undefined
            if (className === null || className === undefined) {
                throw new RequiredError('className','Required parameter className was null or undefined when calling getPluginUsingGET.');
            }
            const localVarPath = `/api/plugins/{className}`
                .replace(`{${"className"}}`, encodeURIComponent(String(className)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPlugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/plugins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginResourceApi - functional programming interface
 * @export
 */
export const PluginResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getPluginDocumentation
         * @param {string} className className
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginDocumentationUsingGET(className: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StringWrapper> {
            const localVarFetchArgs = PluginResourceApiFetchParamCreator(configuration).getPluginDocumentationUsingGET(className, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getPlugin
         * @param {string} className className
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginUsingGET(className: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PluginDTO> {
            const localVarFetchArgs = PluginResourceApiFetchParamCreator(configuration).getPluginUsingGET(className, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getPlugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PluginDTO>> {
            const localVarFetchArgs = PluginResourceApiFetchParamCreator(configuration).getPluginsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PluginResourceApi - factory interface
 * @export
 */
export const PluginResourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getPluginDocumentation
         * @param {string} className className
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginDocumentationUsingGET(className: string, options?: any) {
            return PluginResourceApiFp(configuration).getPluginDocumentationUsingGET(className, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getPlugin
         * @param {string} className className
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginUsingGET(className: string, options?: any) {
            return PluginResourceApiFp(configuration).getPluginUsingGET(className, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getPlugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET(options?: any) {
            return PluginResourceApiFp(configuration).getPluginsUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * PluginResourceApi - object-oriented interface
 * @export
 * @class PluginResourceApi
 * @extends {BaseAPI}
 */
export class PluginResourceApi extends BaseAPI {
    /**
     * 
     * @summary getPluginDocumentation
     * @param {string} className className
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginResourceApi
     */
    public getPluginDocumentationUsingGET(className: string, options?: any) {
        return PluginResourceApiFp(this.configuration).getPluginDocumentationUsingGET(className, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getPlugin
     * @param {string} className className
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginResourceApi
     */
    public getPluginUsingGET(className: string, options?: any) {
        return PluginResourceApiFp(this.configuration).getPluginUsingGET(className, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getPlugins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginResourceApi
     */
    public getPluginsUsingGET(options?: any) {
        return PluginResourceApiFp(this.configuration).getPluginsUsingGET(options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessingChainResourceApi - fetch parameter creator
 * @export
 */
export const ProcessingChainResourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProcessingChain
         * @param {ProcessingChainDTO} body processingChainDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProcessingChainUsingPOST(body: ProcessingChainDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProcessingChainUsingPOST.');
            }
            const localVarPath = `/api/processing-chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessingChainDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteProcessingChainStep
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessingChainStepUsingDELETE(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProcessingChainStepUsingDELETE.');
            }
            const localVarPath = `/api/processing-chains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getProcessingChainSteps
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainStepsUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessingChainStepsUsingGET.');
            }
            const localVarPath = `/api/processing-chains/{id}/steps`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getProcessingChain
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessingChainUsingGET.');
            }
            const localVarPath = `/api/processing-chains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getProcessingChains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/processing-chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateProcessingChain
         * @param {ProcessingChainDTO} body processingChainDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessingChainUsingPUT(body: ProcessingChainDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProcessingChainUsingPUT.');
            }
            const localVarPath = `/api/processing-chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessingChainDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessingChainResourceApi - functional programming interface
 * @export
 */
export const ProcessingChainResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createProcessingChain
         * @param {ProcessingChainDTO} body processingChainDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProcessingChainUsingPOST(body: ProcessingChainDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessingChainDTO> {
            const localVarFetchArgs = ProcessingChainResourceApiFetchParamCreator(configuration).createProcessingChainUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteProcessingChainStep
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessingChainStepUsingDELETE(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessingChainResourceApiFetchParamCreator(configuration).deleteProcessingChainStepUsingDELETE(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getProcessingChainSteps
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainStepsUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessingChainDTO>> {
            const localVarFetchArgs = ProcessingChainResourceApiFetchParamCreator(configuration).getProcessingChainStepsUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getProcessingChain
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessingChainDTO> {
            const localVarFetchArgs = ProcessingChainResourceApiFetchParamCreator(configuration).getProcessingChainUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getProcessingChains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessingChainDTO>> {
            const localVarFetchArgs = ProcessingChainResourceApiFetchParamCreator(configuration).getProcessingChainsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateProcessingChain
         * @param {ProcessingChainDTO} body processingChainDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessingChainUsingPUT(body: ProcessingChainDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessingChainDTO> {
            const localVarFetchArgs = ProcessingChainResourceApiFetchParamCreator(configuration).updateProcessingChainUsingPUT(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessingChainResourceApi - factory interface
 * @export
 */
export const ProcessingChainResourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createProcessingChain
         * @param {ProcessingChainDTO} body processingChainDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProcessingChainUsingPOST(body: ProcessingChainDTO, options?: any) {
            return ProcessingChainResourceApiFp(configuration).createProcessingChainUsingPOST(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteProcessingChainStep
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessingChainStepUsingDELETE(id: number, options?: any) {
            return ProcessingChainResourceApiFp(configuration).deleteProcessingChainStepUsingDELETE(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getProcessingChainSteps
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainStepsUsingGET(id: number, options?: any) {
            return ProcessingChainResourceApiFp(configuration).getProcessingChainStepsUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getProcessingChain
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainUsingGET(id: number, options?: any) {
            return ProcessingChainResourceApiFp(configuration).getProcessingChainUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getProcessingChains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessingChainsUsingGET(options?: any) {
            return ProcessingChainResourceApiFp(configuration).getProcessingChainsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateProcessingChain
         * @param {ProcessingChainDTO} body processingChainDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessingChainUsingPUT(body: ProcessingChainDTO, options?: any) {
            return ProcessingChainResourceApiFp(configuration).updateProcessingChainUsingPUT(body, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessingChainResourceApi - object-oriented interface
 * @export
 * @class ProcessingChainResourceApi
 * @extends {BaseAPI}
 */
export class ProcessingChainResourceApi extends BaseAPI {
    /**
     * 
     * @summary createProcessingChain
     * @param {ProcessingChainDTO} body processingChainDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessingChainResourceApi
     */
    public createProcessingChainUsingPOST(body: ProcessingChainDTO, options?: any) {
        return ProcessingChainResourceApiFp(this.configuration).createProcessingChainUsingPOST(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteProcessingChainStep
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessingChainResourceApi
     */
    public deleteProcessingChainStepUsingDELETE(id: number, options?: any) {
        return ProcessingChainResourceApiFp(this.configuration).deleteProcessingChainStepUsingDELETE(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getProcessingChainSteps
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessingChainResourceApi
     */
    public getProcessingChainStepsUsingGET(id: number, options?: any) {
        return ProcessingChainResourceApiFp(this.configuration).getProcessingChainStepsUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getProcessingChain
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessingChainResourceApi
     */
    public getProcessingChainUsingGET(id: number, options?: any) {
        return ProcessingChainResourceApiFp(this.configuration).getProcessingChainUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getProcessingChains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessingChainResourceApi
     */
    public getProcessingChainsUsingGET(options?: any) {
        return ProcessingChainResourceApiFp(this.configuration).getProcessingChainsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateProcessingChain
     * @param {ProcessingChainDTO} body processingChainDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessingChainResourceApi
     */
    public updateProcessingChainUsingPUT(body: ProcessingChainDTO, options?: any) {
        return ProcessingChainResourceApiFp(this.configuration).updateProcessingChainUsingPUT(body, options)(this.fetch, this.basePath);
    }

}
/**
 * SignalProcessorResourceApi - fetch parameter creator
 * @export
 */
export const SignalProcessorResourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createSignalProcessor
         * @param {SignalProcessorDTO} body signalProcessor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignalProcessorUsingPOST(body: SignalProcessorDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSignalProcessorUsingPOST.');
            }
            const localVarPath = `/api/signal-processors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignalProcessorDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteSignalProcessor
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignalProcessorUsingDELETE(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSignalProcessorUsingDELETE.');
            }
            const localVarPath = `/api/signal-processors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary executeSignalProcessorOperations
         * @param {Array<ProcessorOperationArgument>} body operationArguments
         * @param {number} id id
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSignalProcessorOperationsUsingPUT(body: Array<ProcessorOperationArgument>, id: number, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling executeSignalProcessorOperationsUsingPUT.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling executeSignalProcessorOperationsUsingPUT.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling executeSignalProcessorOperationsUsingPUT.');
            }
            const localVarPath = `/api/signal-processors/{id}/operations/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;ProcessorOperationArgument&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSignalProcessorOperations
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorOperationsUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSignalProcessorOperationsUsingGET.');
            }
            const localVarPath = `/api/signal-processors/{id}/operations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSignalProcessor
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSignalProcessorUsingGET.');
            }
            const localVarPath = `/api/signal-processors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSignalProcessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/signal-processors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateSignalProcessor
         * @param {SignalProcessorDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignalProcessorUsingPUT(body: SignalProcessorDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSignalProcessorUsingPUT.');
            }
            const localVarPath = `/api/signal-processors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignalProcessorDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignalProcessorResourceApi - functional programming interface
 * @export
 */
export const SignalProcessorResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createSignalProcessor
         * @param {SignalProcessorDTO} body signalProcessor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignalProcessorUsingPOST(body: SignalProcessorDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignalProcessorDTO> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).createSignalProcessorUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteSignalProcessor
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignalProcessorUsingDELETE(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).deleteSignalProcessorUsingDELETE(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary executeSignalProcessorOperations
         * @param {Array<ProcessorOperationArgument>} body operationArguments
         * @param {number} id id
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSignalProcessorOperationsUsingPUT(body: Array<ProcessorOperationArgument>, id: number, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).executeSignalProcessorOperationsUsingPUT(body, id, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSignalProcessorOperations
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorOperationsUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessorOperationDesc>> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).getSignalProcessorOperationsUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSignalProcessor
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignalProcessorDTO> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).getSignalProcessorUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSignalProcessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SignalProcessorDTO>> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).getSignalProcessorsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateSignalProcessor
         * @param {SignalProcessorDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignalProcessorUsingPUT(body: SignalProcessorDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SignalProcessorDTO> {
            const localVarFetchArgs = SignalProcessorResourceApiFetchParamCreator(configuration).updateSignalProcessorUsingPUT(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SignalProcessorResourceApi - factory interface
 * @export
 */
export const SignalProcessorResourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createSignalProcessor
         * @param {SignalProcessorDTO} body signalProcessor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSignalProcessorUsingPOST(body: SignalProcessorDTO, options?: any) {
            return SignalProcessorResourceApiFp(configuration).createSignalProcessorUsingPOST(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteSignalProcessor
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSignalProcessorUsingDELETE(id: number, options?: any) {
            return SignalProcessorResourceApiFp(configuration).deleteSignalProcessorUsingDELETE(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary executeSignalProcessorOperations
         * @param {Array<ProcessorOperationArgument>} body operationArguments
         * @param {number} id id
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeSignalProcessorOperationsUsingPUT(body: Array<ProcessorOperationArgument>, id: number, name: string, options?: any) {
            return SignalProcessorResourceApiFp(configuration).executeSignalProcessorOperationsUsingPUT(body, id, name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSignalProcessorOperations
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorOperationsUsingGET(id: number, options?: any) {
            return SignalProcessorResourceApiFp(configuration).getSignalProcessorOperationsUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSignalProcessor
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorUsingGET(id: number, options?: any) {
            return SignalProcessorResourceApiFp(configuration).getSignalProcessorUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSignalProcessors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignalProcessorsUsingGET(options?: any) {
            return SignalProcessorResourceApiFp(configuration).getSignalProcessorsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateSignalProcessor
         * @param {SignalProcessorDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignalProcessorUsingPUT(body: SignalProcessorDTO, options?: any) {
            return SignalProcessorResourceApiFp(configuration).updateSignalProcessorUsingPUT(body, options)(fetch, basePath);
        },
    };
};

/**
 * SignalProcessorResourceApi - object-oriented interface
 * @export
 * @class SignalProcessorResourceApi
 * @extends {BaseAPI}
 */
export class SignalProcessorResourceApi extends BaseAPI {
    /**
     * 
     * @summary createSignalProcessor
     * @param {SignalProcessorDTO} body signalProcessor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public createSignalProcessorUsingPOST(body: SignalProcessorDTO, options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).createSignalProcessorUsingPOST(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteSignalProcessor
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public deleteSignalProcessorUsingDELETE(id: number, options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).deleteSignalProcessorUsingDELETE(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary executeSignalProcessorOperations
     * @param {Array<ProcessorOperationArgument>} body operationArguments
     * @param {number} id id
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public executeSignalProcessorOperationsUsingPUT(body: Array<ProcessorOperationArgument>, id: number, name: string, options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).executeSignalProcessorOperationsUsingPUT(body, id, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSignalProcessorOperations
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public getSignalProcessorOperationsUsingGET(id: number, options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).getSignalProcessorOperationsUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSignalProcessor
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public getSignalProcessorUsingGET(id: number, options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).getSignalProcessorUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSignalProcessors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public getSignalProcessorsUsingGET(options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).getSignalProcessorsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateSignalProcessor
     * @param {SignalProcessorDTO} body space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalProcessorResourceApi
     */
    public updateSignalProcessorUsingPUT(body: SignalProcessorDTO, options?: any) {
        return SignalProcessorResourceApiFp(this.configuration).updateSignalProcessorUsingPUT(body, options)(this.fetch, this.basePath);
    }

}
/**
 * SpaceResourceApi - fetch parameter creator
 * @export
 */
export const SpaceResourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createSpace
         * @param {SpaceDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpaceUsingPOST(body: SpaceDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSpaceUsingPOST.');
            }
            const localVarPath = `/api/spaces`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpaceDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deleteSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpaceUsingDELETE(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteSpaceUsingDELETE.');
            }
            const localVarPath = `/api/spaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getDevicesBelongingToSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesBelongingToSpaceUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDevicesBelongingToSpaceUsingGET.');
            }
            const localVarPath = `/api/spaces/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaceUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpaceUsingGET.');
            }
            const localVarPath = `/api/spaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSpacesBelongingToSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpacesBelongingToSpaceUsingGET(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSpacesBelongingToSpaceUsingGET.');
            }
            const localVarPath = `/api/spaces/{id}/spaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSpaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpacesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/api/spaces`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateSpace
         * @param {SpaceDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpaceUsingPUT(body: SpaceDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSpaceUsingPUT.');
            }
            const localVarPath = `/api/spaces`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpaceDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpaceResourceApi - functional programming interface
 * @export
 */
export const SpaceResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary createSpace
         * @param {SpaceDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpaceUsingPOST(body: SpaceDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpaceDTO> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).createSpaceUsingPOST(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary deleteSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpaceUsingDELETE(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).deleteSpaceUsingDELETE(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getDevicesBelongingToSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesBelongingToSpaceUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceDTO>> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).getDevicesBelongingToSpaceUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaceUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpaceDTO> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).getSpaceUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSpacesBelongingToSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpacesBelongingToSpaceUsingGET(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpaceDTO>> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).getSpacesBelongingToSpaceUsingGET(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSpaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpacesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpaceDTO>> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).getSpacesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateSpace
         * @param {SpaceDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpaceUsingPUT(body: SpaceDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpaceDTO> {
            const localVarFetchArgs = SpaceResourceApiFetchParamCreator(configuration).updateSpaceUsingPUT(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SpaceResourceApi - factory interface
 * @export
 */
export const SpaceResourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary createSpace
         * @param {SpaceDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpaceUsingPOST(body: SpaceDTO, options?: any) {
            return SpaceResourceApiFp(configuration).createSpaceUsingPOST(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary deleteSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpaceUsingDELETE(id: number, options?: any) {
            return SpaceResourceApiFp(configuration).deleteSpaceUsingDELETE(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getDevicesBelongingToSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevicesBelongingToSpaceUsingGET(id: number, options?: any) {
            return SpaceResourceApiFp(configuration).getDevicesBelongingToSpaceUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaceUsingGET(id: number, options?: any) {
            return SpaceResourceApiFp(configuration).getSpaceUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSpacesBelongingToSpace
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpacesBelongingToSpaceUsingGET(id: number, options?: any) {
            return SpaceResourceApiFp(configuration).getSpacesBelongingToSpaceUsingGET(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSpaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpacesUsingGET(options?: any) {
            return SpaceResourceApiFp(configuration).getSpacesUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateSpace
         * @param {SpaceDTO} body space
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpaceUsingPUT(body: SpaceDTO, options?: any) {
            return SpaceResourceApiFp(configuration).updateSpaceUsingPUT(body, options)(fetch, basePath);
        },
    };
};

/**
 * SpaceResourceApi - object-oriented interface
 * @export
 * @class SpaceResourceApi
 * @extends {BaseAPI}
 */
export class SpaceResourceApi extends BaseAPI {
    /**
     * 
     * @summary createSpace
     * @param {SpaceDTO} body space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public createSpaceUsingPOST(body: SpaceDTO, options?: any) {
        return SpaceResourceApiFp(this.configuration).createSpaceUsingPOST(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary deleteSpace
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public deleteSpaceUsingDELETE(id: number, options?: any) {
        return SpaceResourceApiFp(this.configuration).deleteSpaceUsingDELETE(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getDevicesBelongingToSpace
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public getDevicesBelongingToSpaceUsingGET(id: number, options?: any) {
        return SpaceResourceApiFp(this.configuration).getDevicesBelongingToSpaceUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSpace
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public getSpaceUsingGET(id: number, options?: any) {
        return SpaceResourceApiFp(this.configuration).getSpaceUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSpacesBelongingToSpace
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public getSpacesBelongingToSpaceUsingGET(id: number, options?: any) {
        return SpaceResourceApiFp(this.configuration).getSpacesBelongingToSpaceUsingGET(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSpaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public getSpacesUsingGET(options?: any) {
        return SpaceResourceApiFp(this.configuration).getSpacesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateSpace
     * @param {SpaceDTO} body space
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpaceResourceApi
     */
    public updateSpaceUsingPUT(body: SpaceDTO, options?: any) {
        return SpaceResourceApiFp(this.configuration).updateSpaceUsingPUT(body, options)(this.fetch, this.basePath);
    }

}
